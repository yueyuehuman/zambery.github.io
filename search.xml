<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>流式套接字学习笔记</title>
      <link href="/2019/06/19/%E6%B5%81%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/06/19/%E6%B5%81%E5%BC%8F%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>流式套接字依托TCP协议提供面向连接的、可靠的数据传输服务，基于流的特点，使用流式套接字传输的数据形态是没有记录边界的有序数据流。这篇文章是对<a href="https://item.jd.com/11367396.html?cu=true&utm_source=baidu-nks&utm_medium=cpc&utm_campaign=t_262767352_baidunks&utm_term=81441371911_0_d06435f8dbbd457588f74327c4dc3dad" target="_blank" rel="noopener">《Windows网络编程》</a>第五章“流式套接字编程”有关内容的总结，也梳理了我在学习过程中遇到有关问题。</p><a id="more"></a><h1 id="流式套接字的通信过程"><a href="#流式套接字的通信过程" class="headerlink" title="流式套接字的通信过程"></a>流式套接字的通信过程</h1><p>先贴出一张这部分内容<strong>至关重要的图</strong>，展示了流式套接字的具体通信过程与相关的函数操作</p><p><img src="https://i.loli.net/2019/06/19/5d0994bc58fd573223.jpg" alt="基于流式套接字的客户与服务器交互过程"></p><h1 id="流式套接字服务器的工作原理"><a href="#流式套接字服务器的工作原理" class="headerlink" title="流式套接字服务器的工作原理"></a>流式套接字服务器的工作原理</h1><p><img src="https://i.loli.net/2019/06/19/5d0a24622fd3199264.jpg" alt="流式套接字服务器的工作原理.jpg"></p><p>TCP服务器在工作过程中将监听与传输区分开来，如上图所示，服务器为客户的连接请求分配了新的套接字（连接套接字）。实际套接字就是建立在新的连接套接字和客户的套接字之间的，作为服务器与该客户之间的专一通道。而原本处于监听的套接字一直处于监听状态，等待其他客户的连接请求。</p><h1 id="流式套接字相关函数与操作"><a href="#流式套接字相关函数与操作" class="headerlink" title="流式套接字相关函数与操作"></a>流式套接字相关函数与操作</h1><p>这张图再来一遍(￣▽￣)”</p><p><img src="https://i.loli.net/2019/06/19/5d0994bc58fd573223.jpg" alt="基于流式套接字的客户与服务器交互过程"></p><p>根据上图，我们一起来看看通信过程中的基本函数与操作</p><h2 id="创建和关闭套接字"><a href="#创建和关闭套接字" class="headerlink" title="创建和关闭套接字"></a>创建和关闭套接字</h2><p>在WinSock2中完成这个任务的函数式<code>socket()</code>和<code>WSASocket()</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// socket()函数定义</span></span><br><span class="line"><span class="function">SOCKET WSAAPI <span class="title">socket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in <span class="keyword">int</span> af,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> protocol</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>af：确定套接字的通信地址族。目前主要是 IPv4(AF_INET)。</li><li>typr：指定套接字类型。如流式套接字：<code>SOCK_STREAM</code>，数据报套接字：<code>SOCK_DGRAM</code>。</li><li>protocol：指定传输协议，一般为0。</li></ul><p><code>socket()</code>与<code>WSASocket()</code>的返回值是通信实例的句柄，类似文件描述符</p><p>调用<code>closesocket()</code>关闭套接字</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closesocket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in SOCKET s;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>成功返回0，否则返回-1</p><h2 id="指定地址"><a href="#指定地址" class="headerlink" title="指定地址"></a>指定地址</h2><p>使用套接字需要知道通信的本地和远程地址才能进行数据传输，当套接字创建后，并未关联具体的地址。需要通过<code>bind()</code>函数将一本地名字赋予一个未命名的套接字</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">const</span> struct sockaddr *name;</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> namelen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>s：调用<code>socket()</code>返回的描述符。</li><li>name：地址参数，一个指向<code>sockaddr</code>结构的指针。通常使用<code>sockaddr_in</code>进行地址赋值，然后进行强制类型转换为<code>sockaddr</code>。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sockaddr与sockaddr_in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    ushort sa_family;</span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> sin_faily;</span><br><span class="line">    u_short sin_port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_adr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockaddr与sockaddr_in长度一致，其实后者可以看作前者结构中的数据更详细的视图</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>namelen：地址结构的大小。</li></ul><p>如果成功，<code>bind()</code>函数返回0；否则返回-1</p><h3 id="几个关于bind-函数的问题"><a href="#几个关于bind-函数的问题" class="headerlink" title="几个关于bind()函数的问题"></a>几个关于<code>bind()</code>函数的问题</h3><ol><li>具有多个Internet地址的主机上的服务器进程如何为客户端提供服务</li></ol><p>可以将<code>sockaddr</code>设定为<code>INADDR_ANY</code>地址，此时套接字对主机上所有网卡的数据进行检查，只要其协议和目标端口与该套接字一致就接收该数据。</p><ol start="2"><li>客户是否需要<code>bind()</code>操作</li></ol><p><code>bind()</code>操作将本地地址与套接字关联起来，因此作为通信的另一方客户也需要进行<code>bind()</code>操作，只不过客户不需要显式地进行<code>bind()</code>操作，而是在调用<code>connect()</code>或<code>sendto()</code>发送数据前，由系统随机指定一个端口号，并隐式地调用<code>bind()</code>操作</p><ol start="3"><li><code>bind()</code>实现了套接字与本地地址关联，如何获取套接字的远端地址</li></ol><p>当流式套接字建立好连接后，其远端的端点地址也与套接字关联起来，这些信息存储在套接字的内存结构中</p><h2 id="连接套接字"><a href="#连接套接字" class="headerlink" title="连接套接字"></a>连接套接字</h2><h3 id="请求连接"><a href="#请求连接" class="headerlink" title="请求连接"></a>请求连接</h3><p>客户调用<code>connect()</code>请求与服务器连接</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">const</span> struct sockaddr *name,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> namelen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>connect()</code>函数执行的操作：</p><ol><li>对于未绑定的套接字，隐式调用<code>bind()</code>操作。</li><li>在<code>name</code>参数中声明服务器地址。</li><li>触发协议栈向目标地址发送SYN请求，完成TCP三次握手。</li><li>等待服务器响应，由于网络存在的延时，服务器可能无法立刻返回。但<code>connect()</code>函数成功返回即意味着可以到达目标服务器。</li></ol><h3 id="处理进入的连接"><a href="#处理进入的连接" class="headerlink" title="处理进入的连接"></a>处理进入的连接</h3><p>服务器在绑定后需要进行监听来自客户端的请求，通过在套接字上调用<code>listen()</code>完成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> backlog</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><code>listen()</code>函数使服务器进入监听状态，使其对进入的TCP连接请求进行排队。<code>backlog</code>参数指明了改等待队列的上限。</p><p>此后服务器要从已完成连接的请求队列中取出某连接请求，调用<code>accept()</code>函数完成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">    _out struct sockaddr *addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    _inout <span class="keyword">int</span> *addrlen</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>s：监听套接字</li></ul><p><code>accept()</code>函数返回另一个用于数据传输的套接字（连接套接字），连接套接字实际负责连接通信。</p><table><thead><tr><th>套接字</th><th>区别</th></tr></thead><tbody><tr><td>监听套接字</td><td>一个服务器通常只创建一个监听套接字，在服务器生命期中一直存在</td></tr><tr><td>连接套接字</td><td>为每个连接创建一个连接套接字，连接关闭，相应套接字关闭</td></tr></tbody></table><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p><code>send()</code>函数进行数据发送：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">const</span> <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> flags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>s：连接套接字</li><li>buf：指向要发送的字节序列</li><li>len：发送的字节数</li><li>flags：默认为0</li></ul><p><code>send()</code>函数的返回值说明了实际发送的字节总数，默认情况下，<code>send()</code>函数的调用会一直阻塞直到发送了所有数据为止。</p><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p><code>recv()</code>函数进行数据接收：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_in SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">    _out <span class="keyword">char</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">    _in <span class="keyword">int</span> flags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><ul><li>s：连接套接字</li><li>buf：指向要保存接收数据的的应用程序缓冲区</li><li>len：接收缓冲区的字节长度</li><li>flag：默认为0</li></ul><p><code>recv()</code>函数的返回值说明了实际接收的字节总数。</p><p>注意，对于发送与接收数据的两种操作没有服务器与客户的区别。</p><h1 id="一个关于监听套接字与连接套接字的问题"><a href="#一个关于监听套接字与连接套接字的问题" class="headerlink" title="一个关于监听套接字与连接套接字的问题"></a>一个关于监听套接字与连接套接字的问题</h1><p><img src="https://i.loli.net/2019/06/19/5d0a24622fd3199264.jpg" alt="流式套接字服务器的工作原理.jpg"></p><p>再回到这张图，我们已经明白，服务器与客户之间的通信实际是由<code>accept()</code>函数分配的新的套接字——连接套接字完成的。如果我们监听套接字绑定了本地的80端口，那新建立的连接套接字的端口号是多少呢？</p><p>我们不妨先假设：连接套接字使用了一个新的端口，那么服务器与客户的通信实际是由这个新的端口进行传输的。但是通过Wireshark抓包分析发现，如果我们与服务器进行HTTP通信，双方在通信的过程中一直使用的是服务器的80端口。</p><p><img src="https://i.loli.net/2019/06/19/5d0a29486e9e537976.jpg" alt="Wireshark数据包.jpg"></p><p>数据包不会骗人，那么连接套接字只能是与监听套接字使用了同一个端口，可如果所有的连接套接字和监听端口都使用了同一个端口，如何进行区分呢？客户的数据是如何传送到与之相关联的连接套接字上去的呢？</p><p>观察<code>SOCKET</code>结构体就可以发现，它不仅记录了本地通信的地址，也记录了远端的通信地址。当数据到达了上述场景中80端口的接收缓冲区时，每个连接套接字通过自己记录的远端地址从中选择了发送给自己数据。这样虽然使用的是同一个端口，但并不会发生数据的混乱。</p><p><img src="https://i.loli.net/2019/06/19/5d0a2d9d01b8124847.jpg" alt="接收连接"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows网络编程 </tag>
            
            <tag> 流式套接字 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习方法—玩转数据结构第一次结课小结</title>
      <link href="/2019/06/18/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2019/06/18/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在慕课网学完了<a href="https://coding.imooc.com/class/207.html" target="_blank" rel="noopener">玩转数据结构</a>这门课，粗略地过了一遍，自己的算法和编程没有成长多少，倒是被作者一篇关于学习方法总结的文章—<a href="https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&mid=2247483836&idx=1&sn=90854aa76507281403e4dd9cd434a12b&chksm=fd8caefacafb27ec78f999fde4f1217c04c6e2ff28cf51fe511d8fa29d484d9281ff91de8c9c&token=88683563&lang=zh_CN#rd" target="_blank" rel="noopener">如果高效学习有什么秘诀的话，那就都在这里了：）</a>给吸引住了。想想自己学习中走的弯路，感觉字字诛心，后悔没有早看到这篇文章。为了给自己长记性，特此把其中的几点记录下来，常看常思，避免重蹈覆辙。</p><a id="more"></a><h1 id="1）不要完美主义！"><a href="#1）不要完美主义！" class="headerlink" title="1）不要完美主义！"></a>1）不要完美主义！</h1><p>我观察到的大多数同学犯得最最最最大的“错误”，就是在学习上“完美主义”。乃至后续很多其他的问题，在我看来都和这个问题是直接相关的。<strong>不要完美主义！不要完美主义！不要完美主义！重要的事情说三遍。</strong></p><p>举个最经典的例子，也是我经常举的例子，背英语单词（在这里我们先不聊背英语单词是不是好的英语学习方法，我们只看如果我们想要背英语单词的话，应该怎么背）我发现很多同学拿着红宝书，第一个list都没翻过去就放弃了。这是因为每天背完第一个list以后，第二天会发现：第一个list还是有很多单词没掌握，然后就继续背第一个list。然后一周后，发现自己第一个list都搞不定，觉得英语好难，彻底放弃了。这就是“完美主义”：不把第一个list“彻底”掌握不肯继续前进。这样是不对的。背了一个list，能多记一个词，就是进步。就算一个词都没记住，模糊有了印象，也是一种进步。我们不应该过度着眼于我们还不够完美。<strong>学习不是要么0分，要么100分的。</strong> <strong>80分是收获；60分是收获；20分也是收获。有收获最重要。</strong> 但是因为着眼于自己的不完美，最终放弃了，那就是彻底的0分了。</p><p>仔细想，这种“完美主义害死人”的例子特别多。我看到过很多同学，其实是在学习的路上，被自己的“完美主义”逼得“放弃了”——由于学习中有一点没有做好，遭受到了一点点挫折，最终就放弃了整个学习计划。每个人都一定要接受自己的不完美。想开一点：我们都不是小升初考了满分，才能上初中的；也不是中考考了满分，才能读高中的；更不是高考考了满分，才能念大学的；将来也不会是大学所有科目都是满分，才能出来工作。<strong>不完美其实是常态</strong>，根本不会影响我们学习更多更深入的内容。<strong>但是在自学过程中，很多同学却要求自己在自己制定的每一步计划中都达到“完美”，才进行下一步。最终结果，通常都是“放弃”。</strong></p><p>可能有的同学会跳出来反驳我：学习当然要认真啊！在这里，我必须强调，我所说的“不要完美主义”，和“学习认真”是不冲突的。什么是“完美主义”，什么又是“囫囵吞枣”，这是一个“度”，每个人其实不一样。不要“完美主义”，不代表学习可以草率前行。每个人都必须要找到适合自己的学习节奏。</p><blockquote><p>我的经验是：在自己又因为自己的学习进度而沮丧的时候，问自己一句：是不是自己又犯“完美主义”的毛病了：）</p></blockquote><h1 id="2）不要过度“学习路径依赖”，学习要冲着自己的目标去。"><a href="#2）不要过度“学习路径依赖”，学习要冲着自己的目标去。" class="headerlink" title="2）不要过度“学习路径依赖”，学习要冲着自己的目标去。"></a>2）不要过度“学习路径依赖”，学习要冲着自己的目标去。</h1><p>现在信息太发达了，对于大多数领域的知识，网上会有很多所谓的“学习路径”。我不是说这些学习路径没有用，但是不能“过度”依赖这些所谓的学习路径。</p><p>比如，很多同学想学机器学习，大多数学习路径都会告诉你，机器学习需要数学基础。于是，很多同学就转而学习数学去了，非要先把数学学好再去学机器学习。可是发现数学怎么也学不好（在这里，可能完美主义的毛病又犯了），而机器学习却一点儿都没学。最终放弃了机器学习，非常可惜。其实，如果真正去接触机器学习，就会发现，至少在入门阶段，机器学习对数学的要求没有那么高。正因为如此，我一直建议：只要你在本科接触过高数，线数，概率这些科目的基础概念，想学机器学习，就去直接学习机器学习。学习过程中发现自己的数学不够用，再回头补数学。在这种情况下，数学学习得也更有目标性，其实效果更好。</p><p>类似这样的例子还有很多，很多同学想学习做ios  app，就先去精通swift语言，或者想做android  app，就先去精通java语言。在我看来大可不必。以我的经验，只要你有一门编译型语言基础，大概看一下这些语言的基础语法，就可以直接上手ios或者android   app的开发了。先能做出一个最基本的app，在这个过程中，就会意识到语言特性的意义，再回头深入研究语言也不迟。此时还能结合真实的开发任务去理解语言特性，比没有上手app开发，抽象地理解语言特性，有意义的多。</p><p>再比如，我的《算法与数据结构》课程和《玩转算法面试》课程，在视频中都是使用C++进行编码的。虽然我一再强调对于算法的学习，语言不重要，但还是有很多同学表示，要先把C++学透，再回来把课程中的算法学好。这是完全没必要的。事实上，在我的这两门课程中，我看到的收获最大的同学，是那些能够把课程中的算法思想理解清楚，然后用自己熟悉的语言去实现的同学：）</p><p>依然是：不要“过度”学习路径依赖，什么叫“过度”，每个人的标准不一样。每个人都需要寻找自己的那个“度”。</p><h1 id="3）实践！"><a href="#3）实践！" class="headerlink" title="3）实践！"></a>3）实践！</h1><p>前面说了很多和教材选择相关的话题，但对于计算机领域的学习来说，教材的意义其实远远小于实践的意义。如果仅仅是看学习材料就是学习的话，那么教学网站的视频后期处理人员就是水平最高的工程师了。因为每段视频，他们都需要看一遍。<strong>但是，很显然，仅仅是看视频，是无法学到知识的。对于计算机领域的学习来说，真正动手实践去编程是异常重要的。怎么夸大其中的作用都不过分。</strong>这就好比学游泳，必须下水去游泳；或者学开车，必须亲自上路。否则你说的再头头是道，一个小学生文化水平的人，只要他开过车，游过泳，都能在这两个领域瞬间秒杀你。</p><p>很多同学都说我的算法讲得好，其实，我一直认为，这其中的一个最简单的秘诀就是：我带领大家把大多数算法都非常细致的实现了一遍；或者对其中的应用进行了非常具体的实践。反观大多数高校教育，对于算法或者机器学习这种一定程度偏理论的学习，通常非常不强调实践。最终的结果是学习者只是接受了很多抽象的概念，但对其中具体的实现细节，却是云里雾里。我见过太多同学，都明白什么是O(n^2)复杂度，什么是O(nlogn)的复杂度，却问我对于100万的数据规模，为什么自己的选择排序运行起来就没反应了。答案很简单：O(n^2)的复杂度太慢了，100万的数据规模太大了，一般家用计算机转选择排序一时半会儿是转不完的。这些同学一定理解O(n^2)的算法比O(nlogn)的算法慢，却没有真正实践过，不知道这个差距到底是多少。</p><p>在我的课程中，经常遇到有些同学提出这样的问题：这个算法的某句话（或者某段逻辑），为什么要写成A的样子，而不是B的样子？这种问题其实很好，但我觉得解决方法也很简单，实际的去把算法改写成B的样子，实际的运行试试看，看会发生什么。如果发生了错误，仔细分析一下，为什么会有错误？如果没有错误，具体比较一下：A和B两种不同的写法，为什么都正确？又有什么区别？真正的学习上的提高，就发生在这个过程中。我当然可以告诉给同学们一个结果，但是自己亲自实践一遍，相比阅读我给出的一个答案，自己对其中问题理解的深刻程度，是完全不可比拟的。</p><h1 id="4）量变到质变。"><a href="#4）量变到质变。" class="headerlink" title="4）量变到质变。"></a>4）量变到质变。</h1><p>还有很多同学，对于算法的一些问题，会问：老师，你是怎么想到用这样的方法的？对于这类问题，我的回答一般都是：你见的还不够多。</p><p>不知道是不是受高中阶段学习的影响，<em>有一些同学特别执着于就着一个单一的问题，寻找其中的“解题路径”。</em>当然，我不是说这是完全错误的，但也有一个“度”。我的经验是：与其把时间花在这里，不如去见更多问题。比如动态规划，是算法学习的一个难点，很多同学在学会了背包问题的解法之后，总是执着于去追寻：是怎么想到这种状态定义的方法的。可能是我个人水平有限，我无法清楚地解释是如何想到这种状态定义的方法的。但是我的经验告诉我：再去看，去实践100个动态规划相关的问题，然后回头看背包问题，你会发现这种状态定义的方式非常自然。<strong>仅仅对着一个问题思考，很多时候都是死胡同。你见识的还不够多，就不足以帮助你总结出更加“普遍”的问题解决的规律。当你见得足够多的时候，一切就都变得很自然，所谓的“量变到质变”。</strong></p><p>不过，<strong>大多数同学在这个环节都会“犯懒”，企图通过一个问题就理解问题的本质，这其实和企图通过一本教材就精通一个领域的想法是一样的，是不现实的，不可能的。同时，这里又包含着学习过程中的“完美主义”的思想，遇到一个问题一定要把它想的无比透彻。</strong></p><blockquote><p>但是我的经验告诉我：大多数问题，其实都是需要“回头看”的。随着你对一个领域理解的越深入，回头再去看那些曾经的问题，都会产生新的视角，对于很多曾经想不明白的问题也豁然开朗。这也是“进步”的根源。如果卡在一个问题上不前进，不给自己“回头看”的机会，甚至最后是放弃了，就什么也没有学会了。</p></blockquote><p>所以，很多时候，你发现对一些问题“百思不得其解”，或许不是因为自己“笨”，而是因为“还不够努力”：）</p><p><strong>最后，一定要相信时间的力量。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/12/hello-world/"/>
      <url>/2019/06/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
